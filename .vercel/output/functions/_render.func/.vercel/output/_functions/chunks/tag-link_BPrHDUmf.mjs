import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_ICIjUNoW.mjs';

const html = "<p>Here is a short story about a small trick that can help us separate constraints, optimize performance, and have a cool way to insert styles into our pages.</p>\n<p>Anyone who has created a website knows there are many ways to include CSS, so let’s talk about the main ones.</p>\n<h2 id=\"inline-style\">Inline Style</h2>\n<p>This type of CSS insertion is very popular due to new trends in JS frameworks that use “CSS in JS”. This can be done within the style attribute:</p>\n<pre class=\"astro-code vitesse-dark\" style=\"background-color:#121212;color:#dbd7caee; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"html\"><code><span class=\"line\"><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#4D9375\">div</span><span style=\"color:#BD976A\"> style</span><span style=\"color:#666666\">=</span><span style=\"color:#C98A7D77\">\"</span><span style=\"color:#C98A7D\">””</span><span style=\"color:#C98A7D77\">\"</span><span style=\"color:#666666\">>&#x3C;/</span><span style=\"color:#4D9375\">div</span><span style=\"color:#666666\">></span></span>\n<span class=\"line\"></span></code></pre>\n<p>This is great if you have preprocessors to optimize the used CSS or something that can help reduce the large content of the main file. Because the request made through the server will be increasingly larger and must be downloaded in a single file, it will have a significant negative impact on LCP (Largest Contentful Paint) but also a good impact on CLS (Cumulative Layout Shift), because rendering will show things as they will appear, based on the CSS cascade system and the CSSOM.</p>\n<h2 id=\"css-object-model\"><a href=\"https://developer.mozilla.org/es/docs/Web/API/CSS_Object_Model#:~:text=El%20Modelo%20de%20objetos%20CSS,de%20CSS%20de%20forma%20din%C3%A1mica\"><strong>CSS Object Model</strong></a></h2>\n<blockquote>\n<p><strong>With Vanilla CSS</strong> it is impossible to apply inline media queries.</p>\n</blockquote>\n<h2 id=\"internal-styles\">Internal Styles</h2>\n<p>Another way to include CSS within the same HTML is with a <code>&#x3C;style></code> tag to style the web. This allows us to better organize the style within a specific tag and use the cascade system to implement the required style, having the same benefits and drawbacks as using inline style, with the improvement that we can use <code>@media</code> queries.</p>\n<h2 id=\"external-styles\">External Styles</h2>\n<p>Now let’s talk about what brought us here—external styles. This is usually done by extracting all the CSS into an external .css file that can be linked to the HTML with the link tag, but there is a hidden feature here that not many know about, which is how to separate these files by media query:</p>\n<pre class=\"astro-code vitesse-dark\" style=\"background-color:#121212;color:#dbd7caee; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;\" tabindex=\"0\" data-language=\"html\"><code><span class=\"line\"><span style=\"color:#666666\">&#x3C;</span><span style=\"color:#4D9375\">link</span></span>\n<span class=\"line\"><span style=\"color:#BD976A\">  rel</span><span style=\"color:#666666\">=</span><span style=\"color:#C98A7D77\">\"</span><span style=\"color:#C98A7D\">stylesheet</span><span style=\"color:#C98A7D77\">\"</span></span>\n<span class=\"line\"><span style=\"color:#BD976A\">  media</span><span style=\"color:#666666\">=</span><span style=\"color:#C98A7D77\">\"</span><span style=\"color:#C98A7D\">screen and (max-width: 767px)</span><span style=\"color:#C98A7D77\">\"</span></span>\n<span class=\"line\"><span style=\"color:#BD976A\">  href</span><span style=\"color:#666666\">=</span><span style=\"color:#C98A7D77\">\"</span><span style=\"color:#C98A7D\">css/mobile.css</span><span style=\"color:#C98A7D77\">\"</span></span>\n<span class=\"line\"><span style=\"color:#666666\">/></span></span>\n<span class=\"line\"></span></code></pre>\n<p>The benefits of these implementations are that if the web is served through a protocol ≥ HTTP/2, we can handle the download of those resources in parallel with the HTML and improve performance, allowing the browser to choose which CSS to download based on its size or way of displaying content, because this media attribute can be set as any of the normal media queries.</p>\n<p>That’s all for now. Please let me know if you have any posting proposals for the next time.</p>";

				const frontmatter = {"draft":false,"title":"Tag link","selfHealing":"000002","resume":"explains the efficient and effective use of the <img> tag in HTML, focusing on the srcset and sizes attributes. These attributes optimize resource usage based on the device displaying the content, enhancing performance and responsiveness.","image":{"src":"link_siloo8","alt":"link tag"},"publishDate":"2023-05-08 11:39","category":"Tutorials","author":"jorge-saud","tags":["webdev","frontend","img","srcset"]};
				const file = "/Users/giorgiosaud/Projects/personal/giorgiosaud.io/src/content/notes/tag-link.md";
				const url = undefined;
				function rawContent() {
					return "\nHere is a short story about a small trick that can help us separate constraints, optimize performance, and have a cool way to insert styles into our pages.\n\nAnyone who has created a website knows there are many ways to include CSS, so let's talk about the main ones.\n\n## Inline Style\n\nThis type of CSS insertion is very popular due to new trends in JS frameworks that use \"CSS in JS\". This can be done within the style attribute:\n\n```html\n<div style=\"””\"></div>\n```\n\nThis is great if you have preprocessors to optimize the used CSS or something that can help reduce the large content of the main file. Because the request made through the server will be increasingly larger and must be downloaded in a single file, it will have a significant negative impact on LCP (Largest Contentful Paint) but also a good impact on CLS (Cumulative Layout Shift), because rendering will show things as they will appear, based on the CSS cascade system and the CSSOM.\n\n## [**CSS Object Model**](https://developer.mozilla.org/es/docs/Web/API/CSS_Object_Model#:~:text=El%20Modelo%20de%20objetos%20CSS,de%20CSS%20de%20forma%20din%C3%A1mica)\n\n> **With Vanilla CSS** it is impossible to apply inline media queries.\n\n## Internal Styles\n\nAnother way to include CSS within the same HTML is with a `<style>` tag to style the web. This allows us to better organize the style within a specific tag and use the cascade system to implement the required style, having the same benefits and drawbacks as using inline style, with the improvement that we can use `@media` queries.\n\n## External Styles\n\nNow let's talk about what brought us here—external styles. This is usually done by extracting all the CSS into an external .css file that can be linked to the HTML with the link tag, but there is a hidden feature here that not many know about, which is how to separate these files by media query:\n\n```html\n<link\n  rel=\"stylesheet\"\n  media=\"screen and (max-width: 767px)\"\n  href=\"css/mobile.css\"\n/>\n```\n\nThe benefits of these implementations are that if the web is served through a protocol ≥ HTTP/2, we can handle the download of those resources in parallel with the HTML and improve performance, allowing the browser to choose which CSS to download based on its size or way of displaying content, because this media attribute can be set as any of the normal media queries.\n\nThat's all for now. Please let me know if you have any posting proposals for the next time.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"inline-style","text":"Inline Style"},{"depth":2,"slug":"css-object-model","text":"CSS Object Model"},{"depth":2,"slug":"internal-styles","text":"Internal Styles"},{"depth":2,"slug":"external-styles","text":"External Styles"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
