const id = "simplified-explanation-of-the-singleton-design-pattern.md";
						const collection = "notes";
						const slug = "simplified-explanation-of-the-singleton-design-pattern";
						const body = "\nin this blog post, I will try to explain the pattern in a simplified way the Singleton Design Pattern, its main purpose is to reconstruct the instantiation of a class to a singular instance, I need to clarify that the use case is very difficult to find but if you think about it in a deeper way I found some interesting uses.\n\nThe more known use case is to use a class to define the configuration of an application, to make use of this pattern in this use case we need to define a Class with the definitions and a configuration that can instantiate the class only if this instance does not exist like this\n\n```js\nclass AppConfig {\n  constructor() {\n    this.apiEndpoint = \"https://api.example.com\";\n    // Other configuration options\n  }\n}\n\nconst AppConfiguration = (() => {\n  let instance;\n\n  function createInstance() {\n    return new AppConfig();\n  }\n\n  return {\n    getInstance: () => {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\nconst config = AppConfiguration.getInstance();\n```\n\nThis use case can be some const defined in a simplified way centralizing them or defining them in the env vars of the deployment process that is because is typically known as an antipattern and not a real pattern.\n\nThere are 2 ways very handful to use it, one is to use this pattern to govern the state of an application in a simplified way like a JS vanilla application there is an example of this use case\n\n```js\nclass GlobalState {\n  constructor() {\n    this.data = {};\n  }\n\n  setData(key, value) {\n    this.data[key] = value;\n  }\n\n  getData(key) {\n    return this.data[key];\n  }\n}\n\nconst AppState = (() => {\n  let instance;\n\n  function createInstance() {\n    return new GlobalState();\n  }\n\n  return {\n    getInstance: () => {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\n// Usage\nconst appState = AppState.getInstance();\n// Set Data\nappState.setData(\"user\", { id: 1, name: \"John Doe\" });\n// Get Data\nconsole.log(appState.getData(\"user\"));\n```\n\nWith this use case, we can resolve a simple state management centralized\n\nThe other common use case is to use as a Bus or a PubSub system to communicate 2 elements of different scopes\n\n```js\nclass EventBus {\n  constructor() {\n    this.listeners = {};\n  }\n\n  subscribe(event, callback) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n    this.listeners[event].push(callback);\n  }\n\n  publish(event, data) {\n    if (this.listeners[event]) {\n      this.listeners[event].forEach((callback) => callback(data));\n    }\n  }\n}\n\nconst EventManager = (() => {\n  let instance;\n\n  function createInstance() {\n    return new EventBus();\n  }\n\n  return {\n    getInstance: () => {\n      if (!instance) {\n        instance = createInstance();\n      }\n      return instance;\n    },\n  };\n})();\n\n// Usage\nconst eventBus = EventManager.getInstance();\neventBus.subscribe(\"userLoggedIn\", (user) => {\n  console.log(`${user.name} logged in`);\n});\n```\n\n> There are some simple examples of this implementation of the more complex to-understand design pattern the Singleton Pattern.\n";
						const data = {draft:false,title:"Simplified Explanation of the Singleton Design Pattern",resume:"The primary purpose of this pattern is to restrict the instantiation of a class to a single instance. Although its use cases can be rare, Jorge highlights some practical applications.",selfHealing:"000005",image:{src:"singleton_hbupze",alt:"Recicle Singleton image"},publishDate:new Date(1699972740000),author:{slug:"jorge-saud",collection:"team"},category:"development",tags:["design-patterns","development"]};
						const _internal = {
							type: 'content',
							filePath: "/Users/giorgiosaud/Projects/personal/giorgiosaud.io/src/content/notes/simplified-explanation-of-the-singleton-design-pattern.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
