const id = "repository-pattern.md";
						const collection = "notes";
						const slug = "repository-pattern";
						const body = "\nIn the world of frontend development, managing data efficiently is crucial for building scalable and maintainable applications. One architectural pattern that has proven to be highly effective in achieving this goal is the Repository Pattern. Traditionally used in backend development, the Repository Pattern is increasingly being adopted in frontend development for its ability to decouple data access logic from business logic.\n\nThis has been growing with techniques like micro-frontend architecture where we need to decouple and isolate terms but also keep some elements shareables between projects to keep consistency here is where the data management can become a mess, and we need to take some architectural decisions to accomplish this consistency, and avoid rework.\n\n## The Repository Pattern is important for several reasons, that I call STAR-D\n\n- **Separation of concerns (Definition of Clients and Separation of Scopes):** The pattern helps define clear boundaries between different parts of the application. It separates the data access logic (clients, repositories) from the business logic, and Api calls, ensuring that each part of the code has a single responsibility and is easier to manage.\n\n- **Testability:** This means that repositories methods can be easily mocked, making it simpler to write unit tests for your micro-frontend. Leading to more reliable and maintainable code, and also allow us to make mock of simplest request actions and test the failed request scenarios.\n\n- **Abstracted data hadling (Decoupling Component Logic from Data Consumption and Delivery):** The Repository Pattern allows the definition of the component and its logic to be decoupled from how data is consumed and delivered. This means that components can focus purely on rendering and user interaction, while repositories handle data retrieval and processing. This separation of concerns leads to cleaner and more maintainable code.\n\n- **Reusablity:** When we separate the client of the request and the repository method from the interface and declare the methods that shoud be used from the component, you are making a segregation that allows us to use the same client for many repositories because not always but many times when we work with SSO the authorization method in apis is the same, then you dont need to write this login in every call you only write the client well and make the request in the repository, wich allow us also to make the request more abstract and if for come reason the client or request changes the component get the same data and work as well as before, even if the mapping changes the repository take charge of it to avoid changes in the component.\n\n- **Definition Clarity (Type Safety with TypeScript):** Typescript allow us to make more predictable code, and not wait until raise a local dev environment or use console logs to get typos errors, with Ts we can define the interface of our component and the interface of our apis responses to make easy the mapping of the request.\n\nBy incorporating the Repository Pattern, frontend developers can create applications that are not only easier to test and maintain but also more flexible and adaptable to changes.\n\n## Example\n\nIn this example, i will explore how to implement the Repository Pattern in a React application using TypeScript. I will create a folder structure that includes repositories for fetching data from an API and a mock data source. This setup allows us to switch bet\nen real and mock data sources seamlessly, demonstrating the flexibility and ease of testing that the Repository Pattern provides.\n\n### Folder Structure\n\nIn this folder structure, you can create a repository pattern that is framework-agnostic, making it suitable for use in any framework.\n\n```zsh\nsrc/\n  ├── repositories/\n  │   ├── clients/\n  │   │   └── ApiClient.ts\n  │   ├── SummaryRepository.ts\n  │   ├── TransactionsRepository.ts\n  │   └── RepositoryFactory.ts\n  ├── interfaces/\n  │   └── apis\n  │       └── summary\n  │           └── Get.d.ts\n  │           └── GetPaths.ts\n  │       └── transactions\n  │           └── Get.d.ts\n  │           └── GetPaths.ts\n  │           └── Post.d.ts\n  │   └── IApiClient.ts\n  └── components/\n      └── DataComponent.tsx\n```\n\n### Implementation\n\nNow, I will define each file in this folder structure, starting with the simplest one: the interface definitions. Here, we will define and agree upon the API or SDK contract between our component and the requested resource.\n\n```ts\n// src/interfaces/apis/summary/Get.d.ts\nimport { GetPaths } from './GetPaths';\n\nexport interface ISummaryAccountsResponse {\n  'amount': number\n}\nexport interface ISummaryCardsResponse {\n  'amount': number\n}\ntype GetSummaryAccounts = (string:TPaths.SUMMARY_ACCOUNT)=>Promise<ISummaryAccountsResponse>;\ntype GetSummaryCards = (string:TPaths.SUMMARY_CARD)=>Promise<ISummaryCardsResponse>;\nexport type GetData = GetSummaryAccounts & GetSummaryCards;\nexport enum TPaths {\n  SUMMARY_ACCOUNT = 'summary',\n  SUMMARY_CARD = 'summary/card',\n}\n\n\n\n```\n\nAnd the endpoint paths in GetPaths\n\n```ts\n// src/interfaces/apis/summary/GetPaths.ts\nexport enum GetPaths {\n  KEY = 'key',\n  PULIC_KEY = 'pubkey',\n}\n\n```\n\nTransactions should be the same as before\n\n```ts\n// src/interfaces/apis/transactions/Get.ts\nimport { TPaths } from './GetPaths';\n\ninterface ITransaction{\n    date: Date;\n    description: string;\n    amount: number;\n    isCleared: boolean;\n}\nexport interface ITransactions {\n  transactions[]: ITransaction[];\n}\n\ntype GetTransactions = (string:TPaths.TRANSACTIONS)=>Promise<ITransactions>;\nexport type GetData = GetTransactions;\n```\n\n```ts\n// src/interfaces/apis/transactions/GetPaths.ts\nexport enum TPaths {\n  TRANSACTIONS = 'transactions',\n}\n\n```\n\nAll the elements defined in these interfaces are the ones that our already-made component requires to work properly.\n\nThen lets go for more, lets work in the client and try to implement it in 2 ways an axios one and a fetch one\n\nI can also use axios and simplify this client like this\n\n```ts\n// src/repositories/clients/apiClient.ts\n\nimport axios from 'axios';\n\nconst BASE_URL='https://api.example.com';\nconst TOKEN='MY_JWT_TOKEN';\nconst ApiClient= axios.create(BASE_URL);\nconst addTokenInterceptor=(config)=>{\n    const newConfig={...config};\n    return newConfig.commons.headers({\n            Authorization:`Bearer ${TOKEN}`,\n    });\n}\n\nApiClient.interceptors.request.use(addTokenInterceptor);\n\nexport default ApiClient;\n```\n\nor use fetch like this\n\n```ts\n// IapiClient.d.ts\nimport { GetData as TGetData } from './apis/transactions/Get';\nimport { GetData as SGetData} from './apis/summary/Post';\n\ntype GetData=TGetData&SGetData;\n\nexport interface IApiClient {\n  getData: GetData;\n  postData: PostData;\n}\n\n\n```\n\nThis will allow us to use any method request in our repository file, and we can use these clients to fetch data in those repository files.\n\nThe repository file:\n\n```ts\n// src/repositories/summaryRepository.ts\n// if you have request definitions import here like this\n/*import {\n  type ITransactionRequest,\n} from './interfaces/apis/transactions/Get.ts';\n*/\nimport ApiClient from './clients/apiClient.ts';\n\nconst summaryRepository={\n  //and use the payload as param typed from ITransactionRequest\n    async getSummary():ISummary{\n        const summary = await Apiclient.getData('summary')<ISummary>\n        /**\n         * We can get the data, parse it to \n         * comply with ISummary, and then return it.\n         * */\n        return summary;\n    }\n}\n\nexport default summaryRepository\n```\n\nNow we can create as many repositories as we want.\n\nThen we will use the repository factory to allow use one single factory method to get the repository\n\n```ts\n// src/repositories/RepositoryFactory.ts\n\nimport SummaryRepository, { ISummaryRepository } from './summaryRepository.ts';\nimport OtherRepository, { IOtherRepository } from './OtherRepository.ts';\n\ntype Repositories = 'summary' | 'other';\nfunction get(string:'summary'):ISummaryRepository;\nfunction get(string:'other'):IOtherRepository;\nfunction get(string:Repositories):unknown;\n\nfunction get(name: Repositories) {\n  switch (name) {\n    case 'summary':\n      return SummaryRepository;\n    case 'other':\n      return OtherRepository;\n    default:\n      return null;\n  }\n}\n\nexport default {\n    get\n}\n```\n\nThis allow us to make test more easy than mocking axios with moxios or thigs like this because we can use a spy on the repository and mock the resolved value for it when we run the test\n\n```ts\nimport SummaryRepository from '@/repository/summaryRepository.ts';\n\njest.spyOn(SummaryRepository,'getSummary').mockResolvedValue({\n  amount: 100;\n  currency: \"$\";\n  accountNumber: \"123-123-123\";\n});\n```\n\nAs simple as this we can mock the method getSummary and get example data for our test or make it fail.\n\nPlease note that there might be errors in this code as it was not run; it is only meant to illustrate how to use the repository factory. If you find any issues, please report them to my email. \"Once I find the best solution, I will post it with the name of the person who fits best and was first to provide it ;) ....\n";
						const data = {draft:false,title:"Repository pattern in frontend",resume:"The Repository Pattern in frontend development abstracts data access logic, enhancing code maintainability and testability by encapsulating operations and promoting loose coupling. It fosters modular, scalable codebases adaptable to changing requirements.",selfHealing:"000006",image:{src:"repository pattern",alt:"Repository Pattern"},publishDate:new Date(1716299100000),author:{slug:"jorge-saud",collection:"team"},category:"Architecture",tags:["microfrontend","development","frontend","backend"]};
						const _internal = {
							type: 'content',
							filePath: "/Users/giorgiosaud/Projects/personal/giorgiosaud.io/src/content/notes/repository-pattern.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
